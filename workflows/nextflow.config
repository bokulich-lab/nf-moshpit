params {
  condaEnvPath = ""
  condaEnvPathFondue = ""
  imageTag = ""
  email = ""
  executor = ""
  storeDir = ""
  traceDir = ""
  tempDir = "$SCRATCH/tmp"
  cacheLocation = ""
  q2cacheDir = ""
  q2cacheDirExists = "error"
  singularityCacheDir = "$SCRATCH/singularity_cache"
  additionalRunOptionsSingularity = "-B $WORK/tmp:/tmp -B $WORK -H $SCRATCH/tmp_home:/home/qiime2 -B $HOME:$HOME"
  additionalRunOptionsDocker = ""
  inputReads = ""

  fondue {
    cpus = 1
    memoryPerCPU = "2GB"
    clusterOptions = ""
    paired = true
    filesAccessionIds = ""
    time = 4.h
  }

  read_qc {
    n_reads = 10000
    time = 4.h
    memoryPerCPU = "2GB"
    clusterOptions = ""
  }

  read_trimming {
    enabled = false
    paired = true
    adapter_f = ""
    front_f = ""
    anywhere_f = ""
    adapter_r = ""
    front_r = ""
    anywhere_r = ""
    error_rate = 0.1
    indels = true
    times = 1
    overlap = 3
    match_read_wildcards = false
    match_adapter_wildcards = true
    minimum_length = 1
    discard_untrimmed = false
    max_expected_errors = 0
    max_n = 0
    quality_cutoff_5end = 0
    quality_cutoff_3end = 0
    quality_base = 33
    cpus = 1
    memoryPerCPU = "2GB"
    time = 4.h
  }

  host_removal {
    enabled = false
    cpus = 1
    memoryPerCPU = "4GB"
    clusterOptions = ""
    time = 4.h
    database = ""
    mode = "local"
    sensitivity = "sensitive"
    ref_gap_open_penalty = 5
    ref_gap_ext_penalty = 3
    exclude_seqs = true
  }

  read_simulation {
    cpus = 1
    memoryPerCPU = "4GB"
    clusterOptions = ""
    sampleCount = 1
    seed = 100
    nGenomes = 2
    readCount = 200000
    abundance = "uniform"
    gc_bias = true
    sampleGenomes = ""
    sampleNames = (1..params.read_simulation.sampleCount).toList().collect { i -> "sample${i}"}.join(' ')
    taxon = ""
    time = 4.h
  }

  read_subsampling {
    enabled = false
    paired = true
    time = 2.h
    fraction = 0.2
  }

  genome_assembly {
    enable = false
    cpus = 1
    memoryPerCPU = "2GB"
    clusterOptions = ""
    assembler = "megahit"
    time = 4.h
    clusterOptions = ""
    megahit {
      presets = "meta-sensitive"
      kList = "21 29 39 59 79 99 119 141"
      minContigLen = 200
      additionalFlags = ""
    }
    spades {
      k = "auto"
      debug = false
      covCutoff = "off"
      additionalFlags = "--p-meta"
    }
  }

  assembly_qc {
    enabled = false
    useReads = false
    cpus = 1
    memoryPerCPU = "2GB"
    clusterOptions = ""
    time = 4.h
  }

  contig_indexing {
    cpus = 1
    memoryPerCPU = "2GB"
    clusterOptions = ""
    time = 4.h
  }

  read_mapping {
    cpus = 1
    memoryPerCPU = "2GB"
    clusterOptions = ""
    time = 4.h
  }

  dereplication {
    memoryPerCPU = "1GB"
    clusterOptions = ""
    time = 1.h
    threshold = 0.99
    sourmash {
      memoryPerCPU = "1GB"
      clusterOptions = ""
      time = 1.h
      ksizes = 35
      scaled = 100
      trackAbundance = true
    }
  }

  taxonomic_classification {
    enabled = false
    cpus = 1
    memoryPerCPU = "2GB"
    clusterOptions = ""
    kraken2DBpath = ""
    kraken2MemoryMapping = true
    additionalFlags = "--p-quick"
    time = 4.h
    bracken {
      enabled = true
      clusterOptions = ""
      time = 2.h
      brackenDBpath = "/_data/q2_cache:bdb_std"
      threshold = 0
      readLength = 100
      level = "S"
    }
    feature_selection {
      coverageThreshold = 0.1
    }
  }

  functional_annotation {
    enabled = false
    ortholog_search {
      cpus = 1
      memoryPerCPU = "1GB"
      clusterOptions = ""
      time = 4.h
      diamondDBpath = ""
      dbInMemory = false
      additionalFlags = ""
    }
    annotation {
      memoryPerCPU = "1GB"
      clusterOptions = ""
      time = 1.h
      eggnogDBpath = ""
      dbInMemory = false
      additionalFlags = ""
    }
  }

  binning {
    enabled = false
    cpus = 1
    memoryPerCPU = "2GB"
    clusterOptions = ""
    time = 4.h
  }

  binning_qc {
    checkm {
      enabled = false
      cpus = 1
      memoryPerCPU = "2GB"
      clusterOptions = ""
      pplacerThreads = 1
      DBpath = ""
      reducedTree = true
      time = 4.h
    }
    busco {
      enabled = false
      cpus = 1
      memoryPerCPU = "2GB"
      clusterOptions = ""
      time = 4.h
      mode = "genome"
      lineageDataset = "bacteria_odb10"
      additionalFlags = ""
    }
  }

}

env {}

def timestamp = new java.util.Date().format( 'yyyyMMddHHmmss' )
trace {
    enabled = true
    file = "${params.traceDir}/${timestamp}_trace.txt"
}
timeline {
    enabled = true
    file    = "${params.traceDir}/${timestamp}_timeline.html"
}
report {
    enabled = true
    file    = "${params.traceDir}/${timestamp}_report.html"
}
dag {
    enabled = false
    file    = "${params.traceDir}/${timestamp}_dag.svg"
}

profiles {
  conda {
    process.conda = params.condaEnvPath
    if (params.executor) {
        process.executor = params.executor
    }
  }

  singularity {
    singularity.enabled = true
    singularity.autoMounts = false
    singularity.engineOptions = ""
    singularity.runOptions = "${params.additionalRunOptionsSingularity}"
    singularity.envWhitelist = "http_proxy,https_proxy,ftp_proxy"
    singularity.cacheDir = params.singularityCacheDir
    process.container = params.imageTag
    if (params.tempDir) {
        singularity.temp = params.tempDir
    }
    if (params.executor) {
        process.executor = params.executor
    }
  }

  docker {
    docker.enabled = true
    docker.runOptions = "-v ${params.cacheLocation}:/cache ${params.additionalRunOptionsDocker}"
    process.container = params.imageTag
    if (params.tempDir) {
        docker.temp = params.tempDir
    }
    if (params.executor) {
        process.executor = params.executor
    }
  }
}

tower {
  accessToken = ""
  endpoint = ""
  enabled = false
}
